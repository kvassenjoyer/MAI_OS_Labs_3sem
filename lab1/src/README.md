# Лабораторная работа №1


## Сборка лабы:
```
gcc parent.c -o parent
gcc child.c -o child
```

## Запуск лабы:
```
./parent
```

## Отладка лабы с помощью strace:
```
strace -f ./parent
```

## Краткая теория:

### Процессы

1. Абстракция, описывающая выполняемую программу
Обеспечение параллелизма и псевдопараллелизма
2. Экземпляр выполняемой программы, включая значение счетчика
команд, регистров и переменных

#### События, инициализирующие процессы
1. Инициализация системы
2. Работающий процесс осуществляет системный вызов создания нового
процесса
Иерархия процессов
3. Создание процесса по запросу пользователя
4. Инициализация пакетного задания

#### Завершение процесса
1. Обычный выход
2. Выход по обрабатываемой ошибке
3. Возникновение фатальной ошибки
4. Уничтожение другим процессом

#### Unix
1. Процесс создается fork, а далее
exec* заменяет образ памяти
2. Есть иерархия процессов
(Наличие «зомби», «процессов-
сирот»)

#### Реализация процессов
1. Таблица процессов
- Управление процессом (счетчик команд, регистры …)
- Управление памятью (указатели на сегмент данных, стека…)
- Управление файлами (дескрипторы файлов, корневой каталог …)
2. Вектор прерываний

#### ЭЛЕМЕНТЫ, ПРИСУЩИЕ ПРОЦЕССАМ
1. Адресное пространство
2. Глобальные переменные
3. Открытые файлы
4. Дочерние процессы
5. Необработанные аварийные сигналы
6. Сигналы и обработчики событий
7. Учетная информация


---

### Создание новых процессов:

fork() — это системный вызов в Unix-подобных операционных системах, который создает новый процесс. Новый процесс называется дочерним процессом, а процесс, который его создал, — родительским процессом. Дочерний процесс является почти точной копией родительского процесса, включая код, данные, открытые файлы и состояние программы.

Когда вызывается fork(), операционная система делает следующее:

- Создает копию родительского процесса.
Дочерний процесс начинает выполнение с той же точки, где был вызван fork().
- В родительском процессе fork() возвращает идентификатор дочернего процесса (PID).
- В дочернем процессе fork() возвращает 0.
- Если fork() завершается с ошибкой (например, если система не может создать новый процесс), он возвращает -1.

Возвращаемое значение:
- В родительском процессе: PID дочернего процесса (положительное число).
- В дочернем процессе: 0.
- В случае ошибки: -1.

---

### Замена процесса (execl())

execl() — это одна из функций семейства exec, которая используется для замены текущего процесса новым процессом. Когда вы вызываете execl(), текущий процесс (например, ваш запущенный на C) заменяется новой программой, указанной в вызове execl(). Это означает, что код текущего процесса больше не выполняется, а вместо него начинает выполняться код новой программы.

Функции семейства exec (включая execl()) часто используются вместе с fork(). Например:

- Вы создаете дочерний процесс с помощью fork().
- В дочернем процессе вызываете execl(), чтобы заменить его код кодом другой программы.
- Родительский процесс продолжает выполнять свои задачи, а дочерний процесс выполняет новую программу.


```
#include <unistd.h>

int execl(const char *path, const char *arg0, const char *arg1, ..., (char *) NULL);
```

- path — полный путь к исполняемому файлу программы, которую нужно запустить.
- arg0, arg1, ... — аргументы командной строки для новой программы. Первый аргумент (arg0) обычно совпадает с именем программы.
- NULL — завершающий элемент списка аргументов. Он указывает конец списка.

---

### Каналы:
Каналы (pipes) в языке C — это  инструмент для межпроцессного взаимодействия (IPC, Inter-Process Communication). Они позволяют передавать данные между процессами, например, между родительским и дочерним процессом. Каналы работают по принципу "первый вошел, первый вышел" (FIFO, First In, First Out), то есть данные, записанные в канал, читаются в том же порядке, в котором они были записаны.

Канал — это однонаправленный канал связи между процессами. Он имеет два конца:

Конец для записи (write end) — в него можно записывать данные.
Конец для чтения (read end) — из него можно читать данные.
Каналы часто используются для передачи данных между родительским и дочерним процессом, созданным с помощью fork().

Для создания канала используется системный вызов pipe(). Он принимает массив из двух целых чисел, в который записываются два файловых дескриптора:

```
pipefd[0] — дескриптор для чтения (ввода)  
pipefd[1] — дескриптор для записи (вывода)
```

После завершения работы с каналом его концы закрываются с помощью close().

---

### Перенаправление файловых дескрипторов (dup2()) :

dup2() — это системный вызов в Unix-подобных системах, который используется для дублирования файловых дескрипторов. Он позволяет перенаправить один файловый дескриптор на другой. Это особенно полезно для перенаправления стандартного ввода (stdin), стандартного вывода (stdout) и стандартного вывода ошибок (stderr).

#### Синтаксис dup2():
```
#include <unistd.h>

int dup2(int oldfd, int newfd);
```
- oldfd — файловый дескриптор, который нужно скопировать.
- newfd — файловый дескриптор, на который нужно перенаправить oldfd.

Возвращаемое значение:
- В случае успеха возвращает новый файловый дескриптор (newfd).
- В случае ошибки возвращает -1 и устанавливает переменную errno.

---
### wait()

wait() — это системный вызов в Unix-подобных операционных системах, который позволяет родительскому процессу дождаться завершения одного из своих дочерних процессов. Когда дочерний процесс завершается, родительский процесс получает информацию о его статусе завершения.

Когда вы создаете дочерний процесс с помощью fork(), родительский и дочерний процессы выполняются параллельно. Если родительскому процессу нужно дождаться завершения дочернего, он использует wait(). Это полезно в следующих случаях:

- Синхронизация процессов: Родительский процесс может дождаться завершения дочернего, прежде чем продолжить выполнение.
- Получение статуса завершения: Родительский процесс может узнать, как завершился дочерний процесс (успешно, с ошибкой и т.д.).
- Избежание "зомби"-процессов: Если дочерний процесс завершился, но родительский не вызвал wait(), дочерний процесс становится "зомби". Это потребляет ресурсы системы.

#### Синтаксис wait()

```
#include <sys/wait.h>

pid_t wait(int *status);
```
- status — указатель на переменную, в которую будет записан статус завершения дочернего процесса. Если статус не нужен, можно передать NULL.
- Возвращаемое значение:
В случае успеха возвращает PID завершившегося дочернего процесса.
- В случае ошибки возвращает -1 (например, если у родительского процесса нет дочерних процессов).
